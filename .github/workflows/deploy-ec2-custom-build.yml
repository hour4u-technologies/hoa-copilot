name: Build and Deploy to AWS EC2

on:
  push:
    branches:
      - main      # Production deployments
      - develop   # Development deployments
  workflow_dispatch:  # Allows manual triggering
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options:
          - dev
          - prod
      branch:
        description: 'Branch to deploy'
        required: false
        type: string
        default: ''

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  CONTAINER_NAME_PREFIX: hoa-copilot

jobs:
  determine-environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      ec2_host: ${{ steps.set-env.outputs.ec2_host }}
      ec2_user: ${{ steps.set-env.outputs.ec2_user }}
      container_name: ${{ steps.set-env.outputs.container_name }}
      port: ${{ steps.set-env.outputs.port }}
      image_tag: ${{ steps.set-env.outputs.image_tag }}
    steps:
      - name: Set environment
        id: set-env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            ENV="${{ github.event.inputs.environment }}"
          elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
            ENV="prod"
          elif [ "${{ github.ref }}" == "refs/heads/develop" ]; then
            ENV="dev"
          else
            ENV="dev"
          fi
          
          # Get short SHA for image tag
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          IMAGE_TAG="${ENV}-${SHORT_SHA}"
          
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          
          if [ "$ENV" == "prod" ]; then
            echo "ec2_host=${{ secrets.EC2_PROD_HOST }}" >> $GITHUB_OUTPUT
            echo "ec2_user=${{ secrets.EC2_PROD_USER }}" >> $GITHUB_OUTPUT
            echo "container_name=${{ env.CONTAINER_NAME_PREFIX }}-prod" >> $GITHUB_OUTPUT
            echo "port=${{ vars.EC2_PROD_PORT || '80' }}" >> $GITHUB_OUTPUT
          else
            echo "ec2_host=${{ secrets.EC2_DEV_HOST }}" >> $GITHUB_OUTPUT
            echo "ec2_user=${{ secrets.EC2_DEV_USER }}" >> $GITHUB_OUTPUT
            echo "container_name=${{ env.CONTAINER_NAME_PREFIX }}-dev" >> $GITHUB_OUTPUT
            echo "port=${{ vars.EC2_DEV_PORT || '80' }}" >> $GITHUB_OUTPUT
          fi

  build-and-deploy:
    needs: determine-environment
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    environment: ${{ needs.determine-environment.outputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=${{ needs.determine-environment.outputs.image_tag }}
            type=raw,value=${{ needs.determine-environment.outputs.environment }}-latest
            type=sha,prefix=${{ needs.determine-environment.outputs.environment }}-

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILD_HASH=${{ github.sha }}

      - name: Display deployment info
        run: |
          echo "ðŸš€ Deploying to: ${{ needs.determine-environment.outputs.environment }}"
          echo "ðŸ“ EC2 Host: ${{ needs.determine-environment.outputs.ec2_host }}"
          echo "ðŸ³ Container: ${{ needs.determine-environment.outputs.container_name }}"
          echo "ðŸ”Œ Port: ${{ needs.determine-environment.outputs.port }}"
          echo "ðŸ“¦ Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.determine-environment.outputs.image_tag }}"

      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          if [ "${{ needs.determine-environment.outputs.environment }}" == "prod" ]; then
            echo "${{ secrets.EC2_PROD_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          else
            echo "${{ secrets.EC2_DEV_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          fi
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ needs.determine-environment.outputs.ec2_host }} >> ~/.ssh/known_hosts

      - name: Deploy to EC2
        run: |
          IMAGE_TAG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.determine-environment.outputs.image_tag }}"
          ssh -o StrictHostKeyChecking=no ${{ needs.determine-environment.outputs.ec2_user }}@${{ needs.determine-environment.outputs.ec2_host }} << EOF
            set -e
            
            CONTAINER_NAME="${{ needs.determine-environment.outputs.container_name }}"
            PORT="${{ needs.determine-environment.outputs.port }}"
            VOLUME_NAME="open-webui-${{ needs.determine-environment.outputs.environment }}"
            
            echo "ðŸ›‘ Stopping existing container..."
            docker stop \${CONTAINER_NAME} || true
            docker rm \${CONTAINER_NAME} || true
            
            echo "ðŸ“¥ Pulling latest image..."
            docker pull ${IMAGE_TAG}
            
            echo "ðŸ“¦ Creating volume if not exists..."
            docker volume create \${VOLUME_NAME} || true
            
            echo "ðŸš€ Starting new container..."
            docker run -d -p \${PORT}:8080 \
              --add-host=host.docker.internal:host-gateway \
              -v \${VOLUME_NAME}:/app/backend/data \
              --name \${CONTAINER_NAME} \
              --restart always \
              ${IMAGE_TAG}
            
            echo "ðŸ§¹ Cleaning up old images..."
            docker image prune -f
            
            echo "âœ… Deployment completed!"
          EOF

      - name: Verify Deployment
        run: |
          sleep 5
          ssh -o StrictHostKeyChecking=no ${{ needs.determine-environment.outputs.ec2_user }}@${{ needs.determine-environment.outputs.ec2_host }} << EOF
            CONTAINER_NAME="${{ needs.determine-environment.outputs.container_name }}"
            
            echo "ðŸ” Checking container status..."
            if docker ps | grep -q \${CONTAINER_NAME}; then
              echo "âœ… Deployment successful! Container is running."
              echo ""
              echo "Container details:"
              docker ps | grep \${CONTAINER_NAME}
              echo ""
              echo "Container logs (last 20 lines):"
              docker logs --tail 20 \${CONTAINER_NAME}
            else
              echo "âŒ Deployment failed! Container is not running."
              echo ""
              echo "Checking container status:"
              docker ps -a | grep \${CONTAINER_NAME} || echo "Container not found"
              echo ""
              echo "Container logs:"
              docker logs \${CONTAINER_NAME} || echo "No logs available"
              exit 1
            fi
          EOF

      - name: Health Check
        run: |
          sleep 10
          PORT="${{ needs.determine-environment.outputs.port }}"
          HOST="${{ needs.determine-environment.outputs.ec2_host }}"
          
          echo "ðŸ¥ Performing health check..."
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://\${HOST}:\${PORT}/health || echo "000")
          
          if [ "\${HTTP_CODE}" == "200" ]; then
            echo "âœ… Health check passed! Service is healthy."
          else
            echo "âš ï¸ Health check returned code: \${HTTP_CODE}"
            echo "Service may still be starting up. Please verify manually."
          fi
